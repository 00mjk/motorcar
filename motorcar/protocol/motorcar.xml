<?xml version="1.0" encoding="UTF-8"?>
<protocol name="motorcar">
	<interface name="motorcar_shell" version="1">
		<description summary="a 3D compositor shell">
	      	An interface to allow a copositor to composite 3D data from multiple clients
	      	in a manner that makes it appear to be in the same 3D space. Combined with
	      	embedding tradtional wayland surfaces on quads in the same space it provides the 
	      	framework needed to achieve a seamless mixture of 2D and 3D user interfaces while 
	      	still giving clients full flexibility in how their content is drawn to 2D

      		It allows clients to associate a motorcar_surface with a basic surface, which
      		both tells the compositor to perform 3D compositing on the client surface, and also
      		provides a mechanism for the compositor to give the client the information it needs to draw
      		its content to 2D correctly.
   		 </description>

	    <request name="get_motorcar_surface">
	      <description summary="create a motorcar surface from a surface">
		 		Create a motorcar surface for an existing surface.

				Only one motorcar surface can be associated with a given surface.
	      </description>
	      <arg name="id" type="new_id" interface="motorcar_surface"/>
	      <arg name="surface" type="object" interface="wl_surface"/>
	    </request>
	</interface>

	<interface name="motorcar_surface" version="1">

	    <description summary="interface for 3D depth composited motorcar surfaces">
	      An interface that may be implemented by a wl_surface, for
	      implementations that provide motorcar style depth composited 3D surfaces

	      A motorcar_surface can be created from an exisitng surface, and provides the client
	      with the information needed to draw its content in a way that can be depth composited by
	      a motorcar compliant compositor
	    </description>


	</interface>

	<interface name="motorcar_viewpoint" version="1">
		<description summary="represents a single viewpoint in the compositor, essentially a view and projection matrix">
	      This interface represents a viewpoint (essentially a virtual camera) in the compositor's 3D compositing space, 
	      and the events it contains are designed to keep the compositor and client viewpoints synced so that the viewpoints 
	      in the client and compositor space stay consistent;

	    </description>

	    <event name="view_matrix">
	      <description summary="sets the view matrix of this viewpoint for the next frame">
			This event is sent (ideally) at the beginning of each frame to give the client the view
			matrix it needs to draw its content to 2D in the same manner as the compositor.

			This matrix is the view matrix, which brings vectors from world space into view (or camera) space, which is the inverse of the camera transform. 	
	      </description>
	      <arg name="view" type="array" summary="the view matrix for this frame"/>
	    </event>

	    <event name="projection_matrix">
	      <description summary="change the projection matrix of this viewpoint">
			This event is sent immediately after the viewpoint global is bound by the client, and is only resent if the projection
			matrix for this viewpoint changes in the compoisitor (which would be unusual but is certainly possible)

			This matrix is in the form of the projection matrices used by OpenGL, which (with the help of a homogeneous divide
			done in hardware) brings vectors from view space into uniform device coordinate space in which vertices are projected from
			3D to 2D. 

			It is represented here as a column-major 4x4 matrix of 32 bit floats, with all values are specified in meters.
	      </description>
	      <arg name="projection" type="array" summary="the new projection matrix for this viewpoint"/>
	    </event>

	    <event name="view_port">
	      <description summary="sets the view ports of this viewpoint to be used when rendering into motorcar surface buffers">
			This event tells the client where in its surface buffer it needs to draw the output associated with this viewpoint,
			which allows the compositor to extract the correct output for each viewpoint. Like the projection matrix, this event 
			is sent immediately after the client binds this viewpoint global and is only sent again if the viewport changes on the 
			compositor side.

			Viewport consists of a position and a size in surface local coordinates. Each viewpoint has two viewports associated with it,
			one to hold the color buffer from the client, and one to hold the depth buffer contents (which is encoded in the color buffer 
			since EGL does not support a color mode that includes depth). If an EGL extension was written which creates a format that includes
			the depth buffer, then the depth viewport could hypothetically be ignored when that extension was present.
	      </description>
	      <arg name="color_x" type="int" summary="x position of the color viewport, in pixels"/>
	      <arg name="color_y" type="int" summary="y position of the color viewport, in pixels"/>
	      <arg name="color_width" type="uint" summary="width of the color viewport, in pixels"/>
	      <arg name="color_height" type="uint" summary="height of the color viewport, in pixels"/>
	      <arg name="depth_x" type="int" summary="x position of the depth viewport, in pixels"/>
	      <arg name="depth_y" type="int" summary="y position of the depth viewport, in pixels"/>
	      <arg name="depth_width" type="uint" summary="width of the depth viewport, in pixels"/>
	      <arg name="depth_height" type="uint" summary="height of the depth viewport, in pixels"/>
	    </event>


	</interface>


</protocol>